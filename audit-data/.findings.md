
## [S-#] TITLE (Root Cause + Impact)

**Description:** 

**Impact:** 

**Proof of Concept:**

**Recommended Mitigation:** 

## Highs


## [H-1] Incorrect fee  calculation in `TSwapPool::getInputAmountBasedOnOutput` causes protocol to much fee resulting in lost fees

**Description:**  The `getInputAmountBasedOnOutput` function is intended to calculate the amount of tokens a user should deposit given an amount of output tokens, However the function currently miscalculates the resulting amount. When calculating the Fee, it scales the amount by 10_000

**Impact:** Protocol takes more fees than expected from users.


**Recommended Mitigation:** 

```diff
    
    function getInputAmountBasedOnOutput(
        uint256 outputAmount,
        uint256 inputReserves,
        uint256 outputReserves
    )
        public
        pure
        revertIfZero(outputAmount)
        revertIfZero(outputReserves)
        returns (uint256 inputAmount)
    {
-        return ((inputReserves * outputAmount) * 10000) / ((outputReserves - outputAmount) * 997);

+       return ((inputReserves * outputAmount) * 1000) / ((outputReserves - outputAmount) * 997);
    }
```


## [H-2] No slippage protection in `TSwapPool::swapExactOutput`  causes users to potentially receive way fewer tokens

**Description:** `swapExactOutput` function doesn't include any of sort slippage protection. This function is similiar to what is done in `swapExactInput` where the function specifies a `minOutputAmount`, the `swapExactOutput` function should  specifiy `maxInputAmount`

**Impact:** If market conditions change before the transaction processes, the user could get a much worse swap.

**Proof of Concept:**
1. The price of 1 WETH right now is  1000 USDC. 
2. User inputs a `swapExactOutput` looking for 1 WETH.
    1. inputToken = USDC;
    2. OutputToken = WETH,
    3. OutputAmount = 1,
    4. deadline = whatever.

3. The function does not offer a maxInput Amount
4. As the transaction is pending in the mempool, the market changes! and the price moves HUGE  -> WETH is now 10, 000usdc. 10X more than user Expected.
5. The transcation completes, but the user sent the protocol, 10, 000 usdc instead fo the expected 1000usdc.

**Recommended Mitigation:** 


## [H-3] `TSwapPool::sellPoolTokens` mismatches input and output tokens causing users to receive the incorrect amount of tokens

**Description:** The `sellPoolTokens` function is intended to allow users to easily sell pool Tokens and receive WETH  in exchange. Users indicate how many pool tokens they're willing to sell in the `poolTokenAmount` parameter. However, the function currently miscalculates the swapped amount.
This is due  to the fact the  `swapExactOutput` function is called, whereas the `swapExactInput`function is the one that should be called, because users specify the exact amount of input tokens, not output.
**Impact:** Users will swap the wrong amount 


**Recommended Mitigation:** Consider changing the implementation to the `swapExactInput` instead of `swapExactOutput`. Note that this would also require changing the `sellPollTokens` function to accept a new  parameter (ie
`minWethToRecieve` to be passed to `swapExactInput`)

```diff
      function sellPoolTokens(uint256 poolTokenAmount) external returns (uint256 wethAmount, uint256 minWethToReceive) 
      {
        return swapExactOutput(i_poolToken, i_wethToken, poolTokenAmount, uint64(block.timestamp));
    }
```


## [S-#] In  `TSwapPool::_swap` the extra tokens given to users after every `swapCount` breaks the protocol invariant of `x * y = k`

**Description:** The protocol follows a strict invariant of `x * y = k`. Where : 
- `x`: The balance of the  pool token 
- `y`: The balance of WETH
- `K` : The constant product of the two balances

This means, that whenever the balances change in the protocol , the ration between the two amounts should remain constant, hence the `k`. However, this is broken due to the extra incentive in the `_swap` function. Meaning that over time the protocol funds will be drained.

The follow block of code is the main problem
```diff
-        swap_count++;
-        if (swap_count >= SWAP_COUNT_MAX) {
-            swap_count = 0;
-            outputToken.safeTransfer(msg.sender, 1_000_000_000_000_000_000);
        }
```

**Impact:** A user could maliciously drain the protocol of funds by doing a lot of swaps and collecting the extra incentive give out by the protocol

**Proof of Concept:**
1. A user swaps 10 times and gains the extra incentive of `1_000_000_000_000_000_000`
2. That user continues to swap untill all the protocls funds are drained.

<details>
<summary>Proof of code</summary>
place the following code in `TSwapPool.t.sol`

```javascript
        function testInvariantBrokenSwap() public {
        vm.startPrank(liquidityProvider);
        weth.approve(address(pool), 100e18);
        poolToken.approve(address(pool), 100e18);
        pool.deposit(100e18, 100e18, 100e18, uint64(block.timestamp));
        vm.stopPrank();
        uint256 outputWeth = 1e17;
        vm.startPrank(user);
        // Approve tokens so they can be pulled by the pool during the swap
        poolToken.approve(address(pool), type(uint256).max);
        poolToken.mint(user, 100e18);
        pool.swapExactOutput(poolToken, weth, outputWeth, uint64(block.timestamp));
        pool.swapExactOutput(poolToken, weth, outputWeth, uint64(block.timestamp));
        pool.swapExactOutput(poolToken, weth, outputWeth, uint64(block.timestamp));
        pool.swapExactOutput(poolToken, weth, outputWeth, uint64(block.timestamp));
        pool.swapExactOutput(poolToken, weth, outputWeth, uint64(block.timestamp));
        pool.swapExactOutput(poolToken, weth, outputWeth, uint64(block.timestamp));
        pool.swapExactOutput(poolToken, weth, outputWeth, uint64(block.timestamp));
        pool.swapExactOutput(poolToken, weth, outputWeth, uint64(block.timestamp));
        pool.swapExactOutput(poolToken, weth, outputWeth, uint64(block.timestamp));
        pool.swapExactOutput(poolToken, weth, outputWeth, uint64(block.timestamp));
        // receive a reward which breaks the invariant
        pool.swapExactOutput(poolToken, weth, outputWeth, uint64(block.timestamp));
        pool.swapExactOutput(poolToken, weth, outputWeth, uint64(block.timestamp));
        pool.swapExactOutput(poolToken, weth, outputWeth, uint64(block.timestamp));
        pool.swapExactOutput(poolToken, weth, outputWeth, uint64(block.timestamp));
        pool.swapExactOutput(poolToken, weth, outputWeth, uint64(block.timestamp));
        pool.swapExactOutput(poolToken, weth, outputWeth, uint64(block.timestamp));
        pool.swapExactOutput(poolToken, weth, outputWeth, uint64(block.timestamp));
        pool.swapExactOutput(poolToken, weth, outputWeth, uint64(block.timestamp));
        pool.swapExactOutput(poolToken, weth, outputWeth, uint64(block.timestamp));
        int256 startingY = int256(weth.balanceOf(address(pool)));
        int256 expectedDeltaY = int256(-1) * int256(outputWeth);
        pool.swapExactOutput(poolToken, weth, outputWeth, uint64(block.timestamp));
        vm.stopPrank();
        uint256 endingY = weth.balanceOf(address(pool));
        int256 actualDeltaY = int256(endingY) - int256(startingY);
        assertEq(actualDeltaY, expectedDeltaY);
    }
```
</details>

**Recommended Mitigation:** 
Remove extra incentive

## Mediums

## [M-1] `deadline` is not  used in`TswapPool.sol::deposit` causing transactions to complete even after the deadline   

**Description:**  The `deposit` function accepts a deadline parameter, according to the documentation is "  @param deadline The deadline for the transaction to be completed by" however, This parameter is never used. As a consequence, operations that add liquidity to the pool might be executed at unexpected times, in market conditions where the deposit rate is unfavourable.

<!-- Mev attacks -->

**Impact:** Transactions could be sent when market conditions are unfavourable to deposit, even when adding a deadline parameter.

**Proof of Concept:** The `deadline` is unused

**Recommended Mitigation:** Consider making the following change to the function

```diff
 function deposit(
        uint256 wethToDeposit,
        uint256 minimumLiquidityTokensToMint,
        uint256 maximumPoolTokensToDeposit,
        uint64 deadline
    )
        external
        revertIfZero(wethToDeposit)
+       revertIfDeadlinePassed(deadline)        
        returns (uint256 liquidityTokensToMint)
```

## Lows


## [L-1] `TSwapPool::LiquidityAdded` event has parameters out of order.

**Description:** When the `LiquidityAdded` is emitted in the `TSwapPool::_addLiquidityMintAndTransfer ` function, it logs values in an incorrect order. The `poolTokensToDeposit` value should go in the third parameter position,

**Impact:**  Event emission is incorrect, leading to off-chain functions potentially malfunctioning.

**Recommended Mitigation:** 
```diff
-    emit LiquidityAdded(msg.sender, poolTokensToDeposit, wethToDeposit);

+    emit LiquidityAdded(msg.sender,wethToDeposit,poolTokensToDeposit);   
```


## [L-2]  Default value returned by `TSwapPool::swpExactInput` results in incorrect return value given

**Description:**  The `swapExactInput` function is expected to return the actual amount of tokens bought by the caller. However, while it declares the named return value `output` it is never assigned a value, nor uses an  explicit return statement.

**Impact:** The retun valuew will always be 0, giving incorrect information to the caller. 



**Recommended Mitigation:** 
```diff
  {
        uint256 inputReserves = inputToken.balanceOf(address(this));
-       uint256 outputReserves = outputToken.balanceOf(address(this));

+        uint256 outputAmount = getOutputAmountBasedOnInput(inputAmount, inputReserves, outputReserves);

        if (outputAmount < minOutputAmount) {
            revert TSwapPool__OutputTooLow(outputAmount, minOutputAmount);
        }

        _swap(inputToken, inputAmount, outputToken, outputAmount);
    }

```
## Informationals

## [I-1] The error `error PoolFactory__PoolDoesNotExist(address tokenAddress);` in `PoolFactory.sol` is not in the contract functionality.

**Proof of Concept** should be removed
``` diff
-    error PoolFactory__PoolDoesNotExist(address tokenAddress);
```

**Description:** 
The error is highly not to be triggered since PoolFactory is used in creating pools and not removing. 
maybe the contract is not done. and you can check if you wanted to come back and remove pools

**Recommended Mitigation:** remove the error or add a functionality of removing pool from `PoolFactory.sol`

## [I-2] Indexing events `event Swap(address indexed swapper, IERC20 tokenIn, uint256 amountTokenIn, IERC20 tokenOut, uint256 amountTokenOut);`  in `TswapPool.sol`  are missing


**Proof of Concept:**  this should have indexing `event Swap(address indexed swapper, IERC20 tokenIn, uint256 amountTokenIn, IERC20 tokenOut, uint256 amountTokenOut); 
`

**Recommended Mitigation:** : By indexing events, you decouple your system from direct dependencies on the underlying data stores. This means that services don't need to know about the specifics of how data is stored, but can simply react to the events that are emitted


## [I-3] Lacking zero address checks
```javascript
    constructor(address wethToken) {

        // add zero address check 
        i_wethToken = wethToken;
    }
```

**Recommended Mitigation:** add a zero address check.



## [I-4] `PoolFactory::createPool` should use `.symbol()` instead of `.name()`

```diff
-   string memory liquidityTokenSymbol = string.concat("ts", IERC20(tokenAddress).name());

+ string memory liquidityTokenSymbol = string.concat("ts", IERC20(tokenAddress).symbol());
```
**Recommended Mitigation:** 